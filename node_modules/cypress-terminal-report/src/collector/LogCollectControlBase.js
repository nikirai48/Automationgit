"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const CtrError_1 = __importDefault(require("../CtrError"));
class LogCollectControlBase {
    sendLogsToPrinter(logStackIndex, mochaRunnable, options = {}) {
        let testState = (options.state || mochaRunnable.state) || 'running';
        let testTitle = options.title || mochaRunnable.title;
        let testLevel = 0;
        let spec = this.getSpecFilePath(mochaRunnable);
        if (!spec) {
            return;
        }
        let wait = typeof options.wait === 'number' ? options.wait : 5;
        {
            let parent = mochaRunnable.parent;
            while (parent && parent.title) {
                testTitle = `${parent.title} -> ${testTitle}`;
                parent = parent.parent;
                ++testLevel;
            }
        }
        if (testState === 'failed' && mochaRunnable && mochaRunnable._retries > 0) {
            testTitle += ` (Attempt ${mochaRunnable && mochaRunnable._currentRetry + 1})`;
        }
        const prepareLogs = () => {
            return this.prepareLogs(logStackIndex, { mochaRunnable, testState, testTitle, testLevel });
        };
        const buildDataMessage = () => ({
            spec: spec,
            test: testTitle,
            messages: prepareLogs(),
            state: testState,
            level: testLevel,
            consoleTitle: options.consoleTitle,
            isHook: options.isHook,
            continuous: options.continuous,
        });
        this.triggerSendTask(buildDataMessage, options.noQueue || false, wait);
    }
    prepareLogs(logStackIndex, testData) {
        let logsCopy = this.collectorState.consumeLogStacks(logStackIndex);
        if (logsCopy === null) {
            throw new CtrError_1.default(`Domain exception: log stack null.`);
        }
        if (this.config.filterLog) {
            logsCopy = logsCopy.filter(this.config.filterLog);
        }
        if (this.config.processLog) {
            logsCopy = logsCopy.map(this.config.processLog);
        }
        if (this.config.collectTestLogs) {
            this.config.collectTestLogs(testData, logsCopy);
        }
        return logsCopy;
    }
    getSpecFilePath(mochaRunnable) {
        if (!mochaRunnable.invocationDetails && !mochaRunnable.parent.invocationDetails) {
            if (mochaRunnable.parent.file) {
                return mochaRunnable.parent.file;
            }
            return null;
        }
        let invocationDetails = mochaRunnable.invocationDetails;
        let parent = mochaRunnable.parent;
        // always get top-most spec to determine the called .spec file
        while (parent && parent.invocationDetails) {
            invocationDetails = parent.invocationDetails;
            parent = parent.parent;
        }
        return parent.file || // Support for cypress-grep.
            invocationDetails.relativeFile ||
            (invocationDetails.fileUrl && invocationDetails.fileUrl.replace(/^[^?]+\?p=/, ''));
    }
}
exports.default = LogCollectControlBase;
